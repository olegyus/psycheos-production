# PsycheOS: Мастер-план перехода на публичный доступ (v2)

## Исходная точка
- 5 ботов работают локально (polling, python-telegram-bot + aiogram, Claude API напрямую)
- Pro уже умеет создавать ссылку на Screen и получать результат (эта связка сохраняется)
- Все 5 ботов зарегистрированы через BotFather, токены есть
- Бэкенда нет, БД нет, инфраструктуры нет
- Claude API остаётся в коде ботов (вариант А — минимум рефакторинга)
- Реализация: самостоятельно с помощью Claude

## Целевое состояние
- Единый бэкенд (FastAPI) на Railway
- PostgreSQL на Supabase (+ pooler)
- Все боты на webhook через один сервис
- Пропуска (UUID + БД), run_id, артефакты, биллинг
- Idempotency и UNIQUE constraints с первого дня
- Concurrency 30

---

## Сквозные правила (действуют с Фазы 1)

Эти требования — не «hardening на потом», а часть базовой корректности:

1. **Запрет LLM-вызовов в webhook.** Webhook-обработчик делает только: дедуп, чтение/запись FSM, постановку job, ответ 200 OK. Вся тяжёлая работа — в worker.
2. **Идемпотентность везде.** Любое потенциально повторяемое действие (update, job enqueue, artifact submit, usage reserve/commit, outbox) имеет idempotency_key и UNIQUE constraint.
3. **UNIQUE constraints в БД — часть DDL с первого дня**, а не опциональный hardening. Включаются в каждую миграцию при создании таблицы.
4. **Безопасность webhook.** Каждый webhook-роут проверяет Telegram secret token (X-Telegram-Bot-Api-Secret-Token). Без валидного заголовка — 403.

---

## ФАЗА 0: Инфраструктура (фундамент)
**Цель:** площадка готова, можно деплоить код

| # | Шаг | Результат |
|---|------|-----------|
| 0.1 | Создать аккаунт Supabase, проект, получить connection strings (direct + pooler порт 6543) | DB доступна |
| 0.2 | Создать аккаунт Railway, проект `psycheos` | Хостинг готов |
| 0.3 | Создать Sentry проект (бесплатный план) | Мониторинг ошибок |
| 0.4 | Все секреты (API keys, токены ботов, DB URL, webhook secrets) → Railway environment variables | Секреты в env |

---

## ФАЗА 1: Бэкенд-ядро (скелет)
**Цель:** FastAPI сервис, который принимает webhook и хранит состояние

| # | Шаг | Результат |
|---|------|-----------|
| 1.1 | **Решение по библиотеке:** выбрать одну (python-telegram-bot или aiogram) для webhook-режима. Зафиксировать до начала кода | Единый стек |
| 1.2 | Создать структуру проекта FastAPI (main.py, config, database.py, общие модули) | Скелет приложения |
| 1.3 | Подключить SQLAlchemy + Supabase (через pooler, transaction mode, ограничение пула коннектов на процесс) | БД работает |
| 1.4 | Создать DDL: `users`, `bot_chat_state`, `telegram_update_dedup` — **с UNIQUE constraints сразу** | Таблицы FSM и дедупа |
| 1.5 | Реализовать webhook-роуты: `/webhook/pro`, `/webhook/screen`, `/webhook/interpretator`, `/webhook/conceptualizator`, `/webhook/simulator` | Telegram → FastAPI |
| 1.6 | Middleware на каждом роуте: проверка Telegram secret token → дедупликация update_id → загрузка/сохранение bot_chat_state | Stateless + безопасность |
| 1.7 | Реализовать функцию `make_idempotency_key(...)` в общем модуле (формат из Dev Spec Appendix C) | Единый стандарт ключей |
| 1.8 | Задеплоить на Railway (psycheos-api, web service, **НЕ** serverless) | Публичный URL |
| 1.9 | Выставить webhook для каждого бота через Telegram API (setWebhook → Railway URL + secret token) | Polling → webhook |

**Контрольная точка:** отправляете `/start` любому боту → видите запись в `bot_chat_state` в Supabase. Запрос без secret token → 403.

---

## ФАЗА 2: Миграция Pro (gateway)
**Цель:** Pro работает через бэкенд; существующая связка Pro ↔ Screen не ломается

| # | Шаг | Результат |
|---|------|-----------|
| 2.1 | Перенести логику Pro из polling-скрипта в webhook-обработчик FastAPI | Pro через webhook |
| 2.2 | FSM Pro → bot_chat_state (вместо in-memory) | Состояние в БД |
| 2.3 | Создать таблицу `contexts` (кейсы: context_id, specialist_user_id, client_ref, status, timestamps) | Модель данных кейсов |
| 2.4 | Реализовать базовое меню Pro: регистрация, создание кейса, список кейсов | CRUD кейсов |
| 2.5 | Сохранить рабочую связку Pro → Screen (текущий механизм создания ссылки) — она будет формализована в Ф3 | Обратная совместимость |
| 2.6 | Проверить: Pro отвечает, состояние переживает рестарт Railway | Стабильность |

**Контрольная точка:** создаёте кейс в Pro → он в Supabase → рестарт Railway → кейс на месте. Screen по-прежнему получает ссылку и работает.

---

## ФАЗА 3: Пропуска, run_id и маршрутизация
**Цель:** Pro генерирует пропуск + run_id, инструмент-бот проверяет. Единый SSO между ботами

| # | Шаг | Результат |
|---|------|-----------|
| 3.1 | Создать таблицу `link_tokens` (jti UUID PK, service_id, context_id, **run_id**, role, subject_id, expires_at, used_at) — **реализация: UUID + запись в БД, не JWT** | Хранение пропусков |
| 3.2 | Эндпоинт `POST /v1/links/issue` — Pro генерирует run_id (UUID), создаёт запись в link_tokens, возвращает start_param | Выдача пропусков |
| 3.3 | Эндпоинт `POST /v1/links/verify` — проверка: существует, не просрочен, не использован, role соответствует. Возвращает context_id, run_id, role, service_id | Валидация пропусков |
| 3.4 | Правило безопасности: client start_param валиден **только** для service_id=screen. Verify для non-screen → reject | Изоляция ролей |
| 3.5 | В Pro: кнопка «Запустить инструмент» → генерация run_id → issue → deep-link `t.me/BotName?start=TOKEN` | Pro → Tool переход |
| 3.6 | В каждом Tool-боте: при `/start TOKEN` → verify → если valid, начать работу (с context_id и run_id); если нет → «вернитесь в Pro» | Защита доступа |
| 3.7 | Формализовать существующую связку Pro → Screen через тот же механизм (invite с role=client) | Screen на общем протоколе |

**Контрольная точка:** из Pro запускаете Interpretator → бот знает context_id и run_id. Client пытается открыть Interpretator → отказ. Screen по invite работает.

---

## ФАЗА 4: Миграция остальных ботов
**Цель:** все боты на webhook, FSM в БД, доступ через пропуска

| # | Шаг | Результат |
|---|------|-----------|
| 4.1 | Screen: webhook + FSM в БД + verify (role=client) | Screen через бэкенд |
| 4.2 | Interpretator: webhook + FSM + verify (role=specialist) | Interpretator через бэкенд |
| 4.3 | Conceptualizator: webhook + FSM + verify | Conceptualizator через бэкенд |
| 4.4 | Simulator: webhook + FSM + verify | Simulator через бэкенд |
| 4.5 | Для каждого: Claude API вызовы остаются в коде бота (вариант А), но оформляются как job-заготовки (готовность к Ф7) | Минимум изменений + подготовка к worker |

**Контрольная точка:** все 5 ботов работают публично, все через webhook, все FSM в Supabase. Доступ только через пропуска.

---

## ФАЗА 5: Артефакты
**Цель:** результаты инструментов сохраняются с run_id и отображаются в Pro

| # | Шаг | Результат |
|---|------|-----------|
| 5.1 | Создать таблицу `artifacts` (artifact_id, context_id, service_id, **run_id**, artifact_type, payload_json, payload_txt, idempotency_key) + **UNIQUE(service_id, run_id, artifact_type)** | Хранилище результатов |
| 5.2 | Эндпоинт `POST /v1/artifacts/submit` + идемпотентность по ключу | Сохранение артефактов |
| 5.3 | Эндпоинт `GET /v1/artifacts?context_id=...` | Чтение артефактов |
| 5.4 | В каждом Tool-боте: по завершении → submit артефакт (JSON + TXT по единому контракту) с run_id | Инструменты пишут |
| 5.5 | В Pro: по кейсу — список артефактов с возможностью просмотра | Pro читает |

**Контрольная точка:** Screen завершает → артефакт с run_id в БД → специалист видит в Pro. Повторный submit с тем же ключом → тот же artifact_id, не дубль.

---

## ФАЗА 6: Worker + Outbox (устойчивость под нагрузку)
**Цель:** тяжёлые операции не блокируют webhook, отправка с rate-limit

| # | Шаг | Результат |
|---|------|-----------|
| 6.1 | Создать таблицы `jobs` + `outbox_messages` — с UNIQUE constraints и индексами из Dev Spec Appendix B | Очереди в Postgres |
| 6.2 | Реализовать worker-процесс (SKIP LOCKED, pick → execute → done/failed + backoff) | Фоновая обработка |
| 6.3 | Webhook: Claude API вызовы → job в очередь + промежуточное сообщение «обрабатываю» в outbox → быстрый 200 OK | Webhook не блокируется |
| 6.4 | Реализовать sender-процесс: outbox → Telegram sendMessage с per-chat throttle (~1 msg/s) + 429 handling (retry_after → not_before) | Rate-limit отправки |
| 6.5 | Задеплоить psycheos-worker как отдельный Railway service (persistent) | Worker в проде |
| 6.6 | Задеплоить psycheos-cron (чистка истёкших invite, зависших jobs) | Cron в проде |

**Контрольная точка:** 5+ одновременных пользователей → бот не зависает, Claude-ответы приходят через worker, 429 обработаны корректно.

---

## ФАЗА 7: Биллинг (токены)
**Цель:** двухфазное списание с run_id, специалист видит баланс

| # | Шаг | Результат |
|---|------|-----------|
| 7.1 | Создать таблицы `wallets`, `usage_ledger` (с **run_id**, idempotency_key, UNIQUE constraints) | Финансовая модель |
| 7.2 | Эндпоинты: `reserve` (перед операцией), `commit` (после submit), `cancel` (при ошибке) | Двухфазное списание |
| 7.3 | В Tool-ботах (через worker): reserve → операция → submit artifact → commit | Биллинг интегрирован |
| 7.4 | Авто-cancel зависших резервов по TTL (в psycheos-cron) | Защита от утечки |
| 7.5 | В Pro: отображение баланса, история списаний | Прозрачность |
| 7.6 | Таблица `ai_rates` + справка по стоимости операций в Pro | Ценообразование |

**Контрольная точка:** запуск Interpretator → reserve → результат → submit → commit → баланс уменьшился. Падение после reserve → авто-cancel через cron.

---

## ФАЗА 8: Справочник PsycheOS + оплата + финализация Pro
**Цель:** Pro полностью функционален как «консоль специалиста»

| # | Шаг | Результат |
|---|------|-----------|
| 8.1 | Режим «Справочник» в Pro (маршрутизация по типу запроса, service_id=pro_guide, 0 токенов) | Справочник работает |
| 8.2 | Telegram Payments / Stars для пополнения кошелька | Оплата работает |
| 8.3 | Полный UI Pro: кейсы → инструменты → результаты → баланс → справочник | Консоль завершена |

---

## ФАЗА 9: Нагрузочное тестирование и приёмка
**Цель:** Concurrency 30, Definition of Done из Dev Spec

| # | Шаг | Результат |
|---|------|-----------|
| 9.1 | Поднять 2 реплики psycheos-api на Railway | Тест без sticky sessions |
| 9.2 | Прогнать 30 параллельных чатов (скрипт или ручная группа) | Нагрузочный тест |
| 9.3 | Проверить: нет потери FSM, нет дублей (usage_ledger, artifacts), 429 отложены, worker не захлёбывается | DoD Concurrency 30 |
| 9.4 | Настроить Sentry алерты, health-check пинг, метрики (429, глубина очереди, коннекты к БД) | Наблюдаемость |
| 9.5 | Прогнать 5 тест-кейсов из Dev Spec раздел 13 | Приёмка |

---

## Порядок и зависимости

```
Ф0 (инфра) → Ф1 (скелет + правила) → Ф2 (Pro) → Ф3 (пропуска + run_id)
                                                          ↓
                                                   Ф4 (все боты)
                                                          ↓
                                                   Ф5 (артефакты)
                                                          ↓
                                                   Ф6 (worker/outbox)
                                                          ↓
                                                   Ф7 (биллинг)
                                                          ↓
                                                   Ф8 (справочник/оплата)
                                                          ↓
                                                   Ф9 (тест/приёмка)
```

## Ключевые принципы

1. **Один Railway web service = все 5 ботов** (разные webhook-роуты, один деплой)
2. **FSM всегда в БД** — никакого состояния в памяти процесса
3. **Webhook = interrupt handler** — дедуп, FSM, job, 200 OK. Никаких LLM-вызовов
4. **run_id сквозной с Фазы 3** — Pro генерирует, прокидывается через verify → reserve → submit → commit
5. **Идемпотентность и UNIQUE — с первого DDL**, а не «потом добавим»
6. **Claude API остаётся в коде ботов** (вариант А) — не переносим логику промптов в бэкенд
7. **Миграция бот за ботом** — сначала Pro, потом остальные
8. **Worker/outbox раньше биллинга** — сначала устойчивость, потом монетизация
9. **Каждая фаза = рабочая контрольная точка** — можно остановиться и проверить

## Что изменилось (v1 → v2)

- **Пропуска:** зафиксирована реализация UUID + БД (не JWT)
- **run_id:** перенесён из Ф8 в Ф3, сквозной с момента создания пропуска
- **Worker/outbox (бывшая Ф7):** сдвинут в Ф6, до биллинга
- **Биллинг (бывшая Ф6):** стал Ф7, после worker
- **Сквозные правила:** запрет LLM в webhook, идемпотентность, UNIQUE, проверка secret token — действуют с Ф1
- **Решение по библиотеке** (python-telegram-bot vs aiogram): добавлено в Ф1 как первый шаг
- **Фаз стало 10 → 10** (Ф0–Ф9), нумерация компактнее
